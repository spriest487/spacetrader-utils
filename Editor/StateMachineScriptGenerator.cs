using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using JetBrains.Annotations;
using Sirenix.OdinInspector;
using Sirenix.Utilities;
using UnityEditor;
using UnityEngine;

namespace SpaceTrader.Util {
    using MethodRuleTransitionInfoTypeErased = MethodRuleTransitionInfo<IStateMachineState<object>>;

    internal class StateMachineScriptGenerator {
        private readonly struct ReflectedMember {
            public string ID { get; }
            public bool IsStatic { get; }

            public ReflectedMember(string id, bool isStatic) {
                this.ID = id;
                this.IsStatic = isStatic;
            }
        }

        private struct RuleMethod {
            public string MethodName;
            public string MethodDefinition;
        }

        private static readonly Dictionary<string, ValueDropdownItem<Type>> stateTypesDropdownItems;

        private readonly StateMachineScriptSettings source;

        private readonly List<StateMachineScriptBuildReportRule> buildReportRules;

        private readonly Dictionary<MemberInfo, ReflectedMember> reflectionCache;
        private readonly Dictionary<string, string> profilerMarkers;
        private readonly Dictionary<string, RuleMethod> ruleMethods;

        private readonly string baseStateTyName;
        private readonly string ruleTransitionTyName;

        public bool GenerateProfilerMarkers { get; set; }

        public IEnumerable<StateMachineScriptBuildReportRule> BuildReportRules => this.buildReportRules;

        static StateMachineScriptGenerator() {
            stateTypesDropdownItems = new Dictionary<string, ValueDropdownItem<Type>>();
            var candidates = AssemblyUtilities.GetTypes(AssemblyCategory.Scripts 
                | AssemblyCategory.ProjectSpecific 
                | AssemblyCategory.ImportedAssemblies);

            foreach (var type in candidates) {
                if (!IsStateType(type)) {
                    continue;
                }

                stateTypesDropdownItems.Add(type.Name, new ValueDropdownItem<Type>(type.Name, type));
            }
        }

        public StateMachineScriptGenerator(StateMachineScriptSettings source) {
            this.source = source;

            this.buildReportRules = new List<StateMachineScriptBuildReportRule>();

            this.reflectionCache = new Dictionary<MemberInfo, ReflectedMember>();
            this.profilerMarkers = new Dictionary<string, string>();
            this.ruleMethods = new Dictionary<string, RuleMethod>();

            this.baseStateTyName = GetNiceName(this.source.StateType);
            this.ruleTransitionTyName = $"RuleTransition<{this.baseStateTyName}>";
        }

        public void WriteScript(StringBuilder output) {
            var methodRules = this.GetMethodRuleTransitionsTypeErased();

            this.reflectionCache.Clear();
            this.profilerMarkers.Clear();
            this.ruleMethods.Clear();

            output.AppendLine("using System;");
            output.AppendLine("using System.Reflection;");
            output.AppendLine("using System.Collections.Generic;");
            output.AppendLine("using UnityEngine;");
            output.AppendLine("using Unity.Profiling;");
            output.AppendLine("using SpaceTrader.Util;");

            var hasNs = !string.IsNullOrWhiteSpace(this.source.Namespace);

            if (hasNs) {
                output.AppendLine($"namespace {this.source.Namespace} {{");
            }

            output.AppendLine(
                $"public partial class {this.source.GeneratedClassName} : TransitionRuleStateMachine<{this.baseStateTyName}> {{"
            );

            output.AppendLine("#if UNITY_EDITOR");
            output.AppendLine($"public const string SourceAsset = \"{AssetDatabase.GetAssetPath(this.source)}\";");
            output.AppendLine("#endif");

            output.AppendLine(
                $"public {this.source.GeneratedClassName}({this.baseStateTyName} defaultState = default) : base(defaultState) {{"
            );

            var autoGen = this.source.FallbackMode != StateMachineScriptFallbackMode.None;
            var autoGenEditor = this.source.FallbackModeEditor != StateMachineScriptFallbackMode.None;

            output.AppendLine($"if (!Application.isEditor) {{");
            output.AppendLine($"  this.AutoGenerateDelegates = {(autoGen ? "true" : "false")};");
            output.AppendLine($"}} else {{");
            output.AppendLine($"  this.AutoGenerateDelegates = {(autoGenEditor ? "true" : "false")};");
            output.AppendLine($"}}");

            output.AppendLine($"}}");

            output.AppendLine(
                $"protected override bool TryTransitionFrom(in {this.baseStateTyName} fromState, out {this.ruleTransitionTyName} transition) {{"
            );

            output.AppendLine("transition = default;");
            output.AppendLine("var hasTransition = false;");

            output.AppendLine($"switch (fromState) {{");

            foreach (var (stateTy, stateRules) in methodRules) {
                if (stateRules.Count == 0) {
                    continue;
                }
                
                var stateTyName = GetNiceName(stateTy);
                output.AppendLine($"case {stateTyName} s: {{");

                for (var i = 0; i < stateRules.Count; i += 1) {
                    if (i > 0) {
                        output.Append("else ");
                    }
                    this.WriteInvokeRule(stateRules[i], output);
                }

                output.AppendLine($"  break;");
                output.AppendLine($"}}");
            }

            output.AppendLine($"}}");
            
            output.AppendLine($"if (hasTransition) {{");
            output.AppendLine("  this.DoTransition(in transition);");
            output.AppendLine("  return true;");
            output.AppendLine($"}}");

            output.AppendLine($"if (!Application.isEditor) {{");
            this.WriteFallbackTransition(this.source.FallbackMode, output);
            output.AppendLine($"}} else {{");
            this.WriteFallbackTransition(this.source.FallbackModeEditor, output);
            output.AppendLine($"}}");

            output.AppendLine($"}}");

            foreach (var (ruleName, ruleMethod) in this.ruleMethods) {
                output.AppendLine($"/// {ruleName}");
                output.AppendLine(ruleMethod.MethodDefinition);
            }

            WriteStaticReflectionCache(output, this.reflectionCache);
            this.WriteProfilerMarkers(this.profilerMarkers, output);

            output.AppendLine($"}}");

            if (hasNs) {
                output.AppendLine($"}}");
            }
        }

        private void WriteFallbackTransition(StateMachineScriptFallbackMode fallbackMode, StringBuilder output) {
            switch (fallbackMode) {
                case StateMachineScriptFallbackMode.Allow: {
                    output.AppendLine($"return base.TryTransitionFrom(in fromState, out transition);");
                    break;
                }

                case StateMachineScriptFallbackMode.Prompt:
                case StateMachineScriptFallbackMode.Warn: {
                    output.AppendLine($"var fallbackResult = base.TryTransitionFrom(in fromState, out transition);");
                    output.AppendLine($"if (fallbackResult) {{");
                    output.AppendLine(
                        $"  Debug.LogWarningFormat(\"{this.source.GeneratedClassName}: missing baked transition for {{0}}, falling back to dynamic invocation\", transition.Name);"
                    );

                    if (fallbackMode == StateMachineScriptFallbackMode.Prompt) {
                        output.AppendLine($"#if UNITY_EDITOR");
                        output.AppendLine(
                            $"global::SpaceTrader.Util.StateMachineScriptSettings.PromptRegenerate(\"{this.source.GeneratedClassName}\", transition.Name, SourceAsset);"
                        );
                        output.AppendLine($"#endif");
                    }

                    output.AppendLine($"}}");
                    output.AppendLine("return fallbackResult;");
                    break;
                }

                case StateMachineScriptFallbackMode.None:
                default: {
                    output.AppendLine($"transition = default;");
                    output.AppendLine($"return false;");
                    break;
                }
            }
        }

        private static string GetRuleName(in MethodRuleTransitionInfoTypeErased rule) {
            return $"{rule.Method.DeclaringType!.Name}.{rule.Method.Name}";
        }

        private void WriteInvokeRule(in MethodRuleTransitionInfoTypeErased rule, StringBuilder output) {
            var ruleName = GetRuleName(in rule);

            if (!this.ruleMethods.TryGetValue(ruleName, out var ruleMethod)) {
                var methodName = $"Rule_{this.ruleMethods.Count}";

                // since rules are sorted, we should encounter and write the top-most type in the hierarchy first
                var declaringTyName = GetNiceName(rule.Method.DeclaringType);

                var ruleDefinition = new StringBuilder(
                    $"private static bool {methodName}({declaringTyName} s, out {this.ruleTransitionTyName} transition) {{"
                );
                this.WriteRule(in rule, ruleDefinition);
                ruleDefinition.AppendLine($"transition = default;");
                ruleDefinition.AppendLine($"return false;");
                ruleDefinition.AppendLine($"}}");

                ruleMethod = new RuleMethod {
                    MethodName = methodName,
                    MethodDefinition = ruleDefinition.ToString(),
                };
                
                this.ruleMethods.Add(ruleName, ruleMethod);
            }
            
            output.AppendLine($"if ({ruleMethod.MethodName}(s, out transition)) {{");
            output.AppendLine($"  hasTransition = true;");
            output.AppendLine($"}}");
        }

        private void WriteRule(
            in MethodRuleTransitionInfoTypeErased rule,
            StringBuilder output
        ) {
            var ruleName = GetRuleName(in rule);

            output.AppendLine("{");

            if (this.GenerateProfilerMarkers) {
                if (!this.profilerMarkers.TryGetValue(ruleName, out var markerIdent)) {
                    markerIdent = $"ProfilerMarker_{this.profilerMarkers.Count}";
                    this.profilerMarkers.Add(ruleName, markerIdent);
                }

                output.AppendLine($"using var profilerScope = {markerIdent}.Auto();");
            }

            var conditionReflected = false;
            if (rule.Condition != null) {
                var condTy = rule.Condition switch {
                    PropertyInfo property => property.PropertyType,
                    FieldInfo field => field.FieldType,
                    _ => throw new ArgumentOutOfRangeException(),
                };

                var equalityComparer = $"EqualityComparer<{GetNiceName(condTy)}>.Default";

                var condVal = this.InvokeMemberExpr(
                    "s",
                    rule.Condition,
                    Array.Empty<string>(),
                    out conditionReflected
                );

                output.Append($"if (!{equalityComparer}.Equals({condVal}, default)) ");
            }

            output.AppendLine("{");

            bool ruleMethodReflected;
            if (rule.TransitionKind == RuleTransitionKind.Pop) {
                this.WritePopRule("s", ruleName, rule, output, out ruleMethodReflected);
            } else {
                this.WriteStateToStateRule("s", ruleName, rule, output, out ruleMethodReflected);
            }

            output.AppendLine("}");
            output.AppendLine("}");

            this.buildReportRules.Add(
                new StateMachineScriptBuildReportRule {
                    Name = ruleName,
                    ConditionReflected = conditionReflected,
                    RuleMethodReflected = ruleMethodReflected,
                }
            );
        }

        private void WritePopRule(
            string stateExpr,
            string ruleName,
            MethodRuleTransitionInfoTypeErased rule,
            StringBuilder output,
            out bool ruleMethodReflected
        ) {
            var baseStateTyName = GetNiceName(this.source.StateType);

            output.AppendLine("bool popped;");

            var methodExpr = this.InvokeMemberExpr(
                stateExpr,
                rule.Method,
                Array.Empty<string>(),
                out ruleMethodReflected
            );
            if (rule.Method.ReturnType == typeof(void)) {
                output.AppendLine($"{methodExpr};");
                output.AppendLine("popped = true;");
            } else {
                output.AppendLine($"popped = {methodExpr};");
            }

            output.AppendLine("if (popped) {");
            output.AppendLine(
                $"  transition = new RuleTransition<{baseStateTyName}>(\"{ruleName}\", default, RuleTransitionKind.Pop);"
            );
            output.AppendLine("  return true;");
            output.AppendLine("}");
        }

        private void WriteStateToStateRule(
            string stateExpr,
            string ruleName,
            MethodRuleTransitionInfoTypeErased rule,
            StringBuilder output,
            out bool ruleMethodReflected
        ) {
            var baseStateTyName = GetNiceName(this.source.StateType);
            var stateComparer = $"EqualityComparer<{baseStateTyName}>.Default";

            var invokeRule = this.InvokeMemberExpr(
                stateExpr,
                rule.Method,
                Array.Empty<string>(),
                out ruleMethodReflected
            );
            output.AppendLine($"var toState = {invokeRule};");
            output.AppendLine($"if (!{stateComparer}.Equals(default, toState)) {{");
            output.AppendLine(
                $"  transition = new RuleTransition<{baseStateTyName}>(\"{ruleName}\", toState, RuleTransitionKind.{rule.TransitionKind});"
            );
            output.AppendLine("  return true;");
            output.AppendLine($"}}");
        }

        private string InvokeMemberExpr(
            string baseExpr,
            MemberInfo member,
            string[] args,
            out bool reflected
        ) {
            bool isStatic;
            bool isAccessible;
            Type valueTy;

            var baseTy = member.DeclaringType!;

            var internalAccess = false;
            if (baseTy.Namespace != null) {
                foreach (var internalNs in this.source.InternalNamespaceWhitelist) {
                    if (internalNs.EndsWith(".*")) {
                        var nsPrefix = internalNs[..^2];
                        if (baseTy.Namespace.StartsWith(nsPrefix)) {
                            internalAccess = true;
                            break;
                        }
                    } else if (internalNs == baseTy.Namespace) {
                        internalAccess = true;
                        break;
                    }
                }
            }

            switch (member) {
                case FieldInfo field: {
                    GetFieldAccess(field, internalAccess, out isStatic, out isAccessible, out valueTy);
                    break;
                }

                case MethodInfo method: {
                    GetMethodAccess(method, internalAccess, out isStatic, out isAccessible, out valueTy);
                    break;
                }

                case PropertyInfo { GetMethod: { } method }: {
                    GetMethodAccess(method, internalAccess, out isStatic, out isAccessible, out valueTy);
                    break;
                }

                default: {
                    throw new ArgumentOutOfRangeException(
                        nameof(member),
                        $"unsupported member: {member} ({member.MemberType})"
                    );
                }
            }

            var expr = new StringBuilder();
            if (isAccessible) {
                if (isStatic) {
                    expr.Append($"{GetNiceName(member.DeclaringType)}.{member.Name}");
                } else {
                    expr.Append($"{baseExpr}.{member.Name}");
                }

                if (member.MemberType == MemberTypes.Method) {
                    expr.Append("(");
                    expr.Append(string.Join(", ", args));
                    expr.Append(")");
                } else if (args.Length > 0) {
                    expr.Append($"= {args[0]}");
                }

                reflected = false;
            } else {
                if (!this.reflectionCache.TryGetValue(member, out var reflectedMember)) {
                    var memberId = $"CachedMember_{this.reflectionCache.Count}";
                    reflectedMember = new ReflectedMember(memberId, isStatic);

                    this.reflectionCache.Add(member, reflectedMember);
                }

                var castResult = member.MemberType switch {
                    MemberTypes.Method => valueTy != typeof(void),
                    _ => args.Length == 0,
                };

                expr = new StringBuilder();

                if (castResult) {
                    expr.Append($"({GetNiceName(valueTy)})");
                }

                expr.Append(reflectedMember.ID);
                var invokeTarget = isStatic ? "null" : baseExpr;

                if (member.MemberType == MemberTypes.Method) {
                    expr.Append($".Invoke({invokeTarget}, ");

                    expr.Append("new object[] {");
                    expr.Append(string.Join(", ", args));
                    expr.Append("})");
                } else {
                    if (args.Length > 0) {
                        expr.Append($".SetValue({invokeTarget}, {args[0]})");
                    } else {
                        expr.Append($".GetValue({invokeTarget})");
                    }
                }

                reflected = true;
            }

            return expr.ToString();
        }

        private static void GetFieldAccess(
            FieldInfo field,
            bool internalAccess,
            out bool isStatic,
            out bool isAccessible,
            out Type valueTy
        ) {
            var attrs = field.Attributes;

            isStatic = attrs.HasFlag(FieldAttributes.Static);
            isAccessible = attrs.HasFlag(FieldAttributes.Public);
            if (internalAccess) {
                isAccessible |= attrs.HasFlag(FieldAttributes.Assembly) || attrs.HasFlag(FieldAttributes.FamORAssem);
            }

            valueTy = field.FieldType;
        }

        private static void GetMethodAccess(
            MethodInfo method,
            bool internalAccess,
            out bool isStatic,
            out bool isAccessible,
            out Type valueTy
        ) {
            var attrs = method.Attributes;

            isStatic = attrs.HasFlag(MethodAttributes.Static);
            isAccessible = attrs.HasFlag(MethodAttributes.Public);
            if (internalAccess) {
                isAccessible |= attrs.HasFlag(MethodAttributes.Assembly) || attrs.HasFlag(MethodAttributes.FamORAssem);
            }

            valueTy = method.ReturnType;
        }

        private static void WriteStaticReflectionCache(
            StringBuilder output,
            Dictionary<MemberInfo, ReflectedMember> reflectionCache
        ) {
            foreach (var (member, reflected) in reflectionCache) {
                var bindingFlags = BindingFlags.NonPublic;
                if (reflected.IsStatic) {
                    bindingFlags |= BindingFlags.Static;
                } else {
                    bindingFlags |= BindingFlags.Instance;
                }

                var (fieldTy, getMember) = member.MemberType switch {
                    MemberTypes.Field => ("FieldInfo", "GetField"),
                    MemberTypes.Property => ("PropertyInfo", "GetProperty"),
                    MemberTypes.Method => ("MethodInfo", "GetMethod"),
                    _ => throw new InvalidOperationException("bad member type"),
                };

                var sourceTyName = GetNiceName(member.DeclaringType);

                output.AppendFormat(
                    "private static readonly {0} {1} = typeof({2}).{3}(\"{4}\", (BindingFlags){5});",
                    fieldTy,
                    reflected.ID,
                    sourceTyName,
                    getMember,
                    member.Name,
                    (int)bindingFlags
                );
                output.AppendLine();
            }
        }

        private void WriteProfilerMarkers(Dictionary<string, string> profilerMarkers, StringBuilder output) {
            foreach (var (ruleName, markerIdent) in profilerMarkers) {
                var markerName = $"{this.source.GeneratedClassName} - {ruleName}";

                output.AppendLine(
                    $"private static readonly ProfilerMarker {markerIdent} = new ProfilerMarker(\"{markerName}\");"
                );
            }
        }

        private static string GetNiceName(Type type) {
            if (type.IsConstructedGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>)) {
                return GetNiceName(type.GetGenericArguments()[0]) + "?";
            }

            return type.IsPrimitive ? type.GetNiceName() : type.GetCompilableNiceFullName();
        }

        private Dictionary<Type, List<MethodRuleTransitionInfoTypeErased>> GetMethodRuleTransitionsTypeErased() {
            var stateMachineBaseTy = typeof(TransitionRuleStateMachine<>).MakeGenericType(this.source.StateType);
            var findRulesMethod = stateMachineBaseTy.GetMethod(
                "FindRulesForType",
                BindingFlags.Public | BindingFlags.Static
            );

            var baseRuleTy = typeof(MethodRuleTransitionInfo<>).MakeGenericType(this.source.StateType);

            var cacheTy = typeof(Dictionary<,>).MakeGenericType(
                typeof(Type),
                typeof(List<>).MakeGenericType(baseRuleTy)
            );

            var rulesCache = (IDictionary)Activator.CreateInstance(cacheTy);

            var allStateTypes = stateTypesDropdownItems.Values
                .Select(static item => item.Value)
                .Where(x => this.source.StateType.IsAssignableFrom(x))
                .ToList();

            var sortedStateTypes = new List<Type>();
            if (allStateTypes.TopologicalSort(x => GetBaseType(x, allStateTypes), sortedStateTypes)) {
                sortedStateTypes.Reverse();
            } else {
                Debug.LogWarning("sorting type hierarchy failed");
                sortedStateTypes = allStateTypes;
            }

            var ruleTy = typeof(MethodRuleTransitionInfo<>).MakeGenericType(this.source.StateType);
            var methodProp = ruleTy.GetProperty("Method", BindingFlags.Public | BindingFlags.Instance);
            var kindProp = ruleTy.GetProperty("TransitionKind", BindingFlags.Public | BindingFlags.Instance);
            var condProp = ruleTy.GetProperty("Condition", BindingFlags.Public | BindingFlags.Instance);

            var rules = new Dictionary<Type, List<MethodRuleTransitionInfoTypeErased>>();

            var uniqueMethods = new HashSet<int>();

            foreach (var stateTy in sortedStateTypes) {
                if (!rules.TryGetValue(stateTy, out var stateRules)) {
                    stateRules = new List<MethodRuleTransitionInfoTypeErased>();
                    rules.Add(stateTy, stateRules);
                }

                var newRules = (IList)findRulesMethod!.Invoke(
                    null,
                    new object[] {
                        stateTy,
                        false,
                        rulesCache,
                    }
                );

                uniqueMethods.Clear();

                foreach (var newRule in newRules) {
                    var method = (MethodInfo)methodProp!.GetValue(newRule);
                    if (!uniqueMethods.Add(method.MetadataToken)) {
                        continue;
                    }

                    var kind = (RuleTransitionKind)kindProp!.GetValue(newRule);
                    var cond = (MemberInfo)condProp!.GetValue(newRule);

                    stateRules.Add(
                        new MethodRuleTransitionInfoTypeErased(method, kind, cond, null)
                    );
                }
            }

            var sortingBuf = new List<MethodRuleTransitionInfoTypeErased>();
            foreach (var (stateTy, stateRules) in rules) {
                sortingBuf.Clear();
                sortingBuf.AddRange(stateRules);

                stateRules.Clear();
                if (sortingBuf.TopologicalSort(x => GetBaseRules(x, sortingBuf), stateRules)) {
                    stateRules.Reverse();
                } else {
                    Debug.LogWarningFormat(
                        "{0}: failed to sort rules for {1}",
                        nameof(StateMachineScriptGenerator),
                        stateTy
                    );
                    stateRules.Clear();
                    stateRules.AddRange(sortingBuf);
                }
            }

            return rules;
        }

        private static IEnumerable<MethodRuleTransitionInfoTypeErased> GetBaseRules(
            MethodRuleTransitionInfoTypeErased rule,
            List<MethodRuleTransitionInfoTypeErased> candidates
        ) {
            var baseTy = rule.Method.DeclaringType?.BaseType;
            if (baseTy == null) {
                yield break;
            }

            foreach (var candidate in candidates) {
                if (candidate.Method.DeclaringType == baseTy) {
                    yield return candidate;
                }
            }
        }

        private static IEnumerable<Type> GetBaseType(Type type, List<Type> candidates) {
            if (type?.BaseType == null) {
                yield break;
            }

            if (!candidates.Contains(type.BaseType)) {
                yield break;
            }

            yield return type.BaseType;
        }

        private static bool IsStateType(Type type) {
            foreach (var iface in type.GetInterfaces()) {
                if (iface.IsGenericType && iface.GetGenericTypeDefinition() == typeof(IStateMachineState<>)) {
                    return true;
                }
            }

            return type.BaseType != null && IsStateType(type.BaseType);
        }

        [UsedImplicitly]
        private static IEnumerable<ValueDropdownItem<Type>> GetStateTypes() {
            return stateTypesDropdownItems.Values;
        }

        public static bool GetStateType(string typeName, out Type type) {
            type = null;

            if (string.IsNullOrWhiteSpace(typeName)) {
                return false;
            }

            if (!stateTypesDropdownItems.TryGetValue(typeName, out var typeItem)) {
                return false;
            }

            type = typeItem.Value;
            return true;
        }
    }
}
