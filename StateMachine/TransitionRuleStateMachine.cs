using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using JetBrains.Annotations;
using UnityEngine;

namespace SpaceTrader.Util {
    public enum RuleTransitionKind {
        None = default,
        Push,
        Pop,
        Replace,
        Reset,
    }

    public readonly struct RuleTransition<T>
        where T : IStateMachineState<T> {
        public string Name { get; }
        
        public T ToState { get; }
        public RuleTransitionKind TransitionKind { get; }

        public RuleTransition(string name, T toState, RuleTransitionKind transitionKind) {
            this.Name = name;
            this.ToState = toState;
            this.TransitionKind = transitionKind;
        }
    }

    public class MethodRuleTransitionInfo<T> where T: IStateMachineState<T> {
        public MethodInfo Method { get; }
        
        public RuleTransitionKind TransitionKind { get; }
        
        [CanBeNull]
        public MemberInfo Condition { get; }

        [CanBeNull]
        public TransitionRuleDelegate<T> Delegate { get; }

        public MethodRuleTransitionInfo(MethodInfo method, RuleTransitionKind transitionKind, [CanBeNull] MemberInfo condition, [CanBeNull] TransitionRuleDelegate<T> @delegate) {
            this.Method = method;
            this.TransitionKind = transitionKind;
            this.Condition = condition;
            this.Delegate = @delegate;
        }
    }

    public delegate void TransitionRuleTriggeredDelegate(Type stateType, string transitionRuleName);
    public delegate void TransitionRuleDelegate<T>(TransitionRuleStateMachine<T> stateMachine, T fromState, out RuleTransition<T> transition)
        where T : IStateMachineState<T>;

    public class TransitionRuleStateMachine<T> : StateMachine<T>
        where T : IStateMachineState<T> {
        
        private const BindingFlags ConditionMemberBindingFlags = BindingFlags.Public 
            | BindingFlags.NonPublic 
            | BindingFlags.Instance;

        private const BindingFlags RuleMethodBindingFlags = BindingFlags.Public
            | BindingFlags.NonPublic
            | BindingFlags.Instance
            | BindingFlags.InvokeMethod;

        private readonly Dictionary<Type, List<MethodRuleTransitionInfo<T>>> transitionRules;

        public event TransitionRuleTriggeredDelegate RuleTriggered;

        protected bool AutoGenerateDelegates { get; set; } = false;

        public TransitionRuleStateMachine(T defaultState, bool autoGenerateDelegates = true) : base(defaultState) {
            this.transitionRules = new Dictionary<Type, List<MethodRuleTransitionInfo<T>>>(8);

            this.BeforeStateChange += this.OnBeforeStateChange;
            this.AutoGenerateDelegates = autoGenerateDelegates;

            if (this.DefaultState != null && autoGenerateDelegates) {
                this.ProcessTransitionRules(this.DefaultState);
            }
        }

        private void OnBeforeStateChange(in StateTransition<T> transition) {
            if (transition.NextState is not { } nextState) {
                return;
            }

            this.ProcessTransitionRules(nextState);
        }

        private void ProcessTransitionRules(T state) {
            var stateType = state.GetType();

            if (this.AutoGenerateDelegates) {
                this.CreateRuleDelegatesForType(stateType, createDelegates: true);
            }
        }

        public static List<MethodRuleTransitionInfo<T>> FindRulesForType(Type type, bool createDelegates, [CanBeNull] Dictionary<Type, List<MethodRuleTransitionInfo<T>>> cache = null) {
            cache ??= new Dictionary<Type, List<MethodRuleTransitionInfo<T>>>();
            
            if (cache.TryGetValue(type, out var rules)) {
                return rules;
            }

            rules = new List<MethodRuleTransitionInfo<T>>();
            cache[type] = rules;

            var baseType = type.BaseType;
            if (baseType != null) {
                rules.AddRange(FindRulesForType(baseType, createDelegates));
            }

            var ruleMethods = type.GetMethods(RuleMethodBindingFlags);

            foreach (var method in ruleMethods) {
                var ruleDelegate = GetMethodRule(type, method, createDelegates);
                if (ruleDelegate != null) {
                    rules.Add(ruleDelegate);
                }
            }

            return rules;
        }

        private void CreateRuleDelegatesForType(Type type, bool createDelegates) {
            FindRulesForType(type, createDelegates, this.transitionRules);
        }

        [CanBeNull]
        private static MethodRuleTransitionInfo<T> GetMethodRule(Type stateType, MethodInfo method, bool createDelegate) {
            if (method.GetCustomAttribute<TransitionRuleAttribute>() is not { } ruleAttribute) {
                return null;
            }

            var transitionKind = ruleAttribute.TransitionKind;

            var conditionMember = (MemberInfo)null;
            var conditionDefaultVal = (object)null;

            if (ruleAttribute.Condition != null) {
                var conditionValueType = (Type)null;

                var conditionProperty = stateType.GetProperty(ruleAttribute.Condition, ConditionMemberBindingFlags);
                if (conditionProperty != null) {
                    conditionMember = conditionProperty;
                    conditionValueType = conditionProperty.PropertyType;
                } else {
                    var conditionField = stateType.GetField(ruleAttribute.Condition, ConditionMemberBindingFlags);
                    if (conditionField != null) {
                        conditionMember = conditionField;
                        conditionValueType = conditionField.FieldType;
                    }
                }
                
                if (conditionMember == null) {
                    Debug.LogErrorFormat(
                        "could not find condition member {0} of {1} for transition rule {2}",
                        ruleAttribute.Condition,
                        stateType,
                        method.Name
                    );
                } else if (conditionValueType.IsValueType) {
                    try {
                        conditionDefaultVal = Activator.CreateInstance(conditionValueType);
                    } catch (Exception e) {
                        Debug.LogErrorFormat(
                            "failed to create default value for condition member {0} of {1} for transition rule {2}: {3}",
                            ruleAttribute.Condition,
                            stateType,
                            method.Name, 
                            e
                        );
                        conditionMember = null;
                    }
                }
            }

            var ruleDelegate = default(TransitionRuleDelegate<T>);
            if (createDelegate) {
                ruleDelegate = transitionKind switch {
                    RuleTransitionKind.Pop => ExecutePopTransitionRuleMethod,
                    _ => ExecuteTransitionRuleMethod,
                };
            }

            return new MethodRuleTransitionInfo<T>(
                method,
                transitionKind,
                conditionMember,
                ruleDelegate
            );

            bool IsConditionActive(T state) {
                switch (conditionMember) {
                    case PropertyInfo conditionProperty: {
                        var conditionValue = conditionProperty.GetValue(state);
                        return !Equals(conditionDefaultVal, conditionValue);
                    }

                    case FieldInfo conditionField: {
                        var conditionValue = conditionField.GetValue(state);
                        return !Equals(conditionDefaultVal, conditionValue);
                    }
                }

                return true;
            }

            void ExecuteTransitionRuleMethod(TransitionRuleStateMachine<T> stateMachine, T fromState, out RuleTransition<T> ruleTransition) {
                using var profilerSegment = new ProfilerSegment("TransitionRuleStateMachine - Execute Transition Rule");

                if (!IsConditionActive(fromState) || method.Invoke(fromState, null) is not T toState) {
                    ruleTransition = default;
                    return;
                }

                try {
                    stateMachine.RuleTriggered?.Invoke(stateType, method.Name);
                } catch (Exception e) {
                    Debug.LogException(e);
                }

                ruleTransition = new RuleTransition<T>(method.Name, toState, transitionKind);
            }

            void ExecutePopTransitionRuleMethod(TransitionRuleStateMachine<T> stateMachine, T fromState, out RuleTransition<T> ruleTransition) {
                using var profilerSegment = new ProfilerSegment("TransitionRuleStateMachine - Execute Transition Rule");

                if (!IsConditionActive(fromState)) {
                    ruleTransition = default;
                    return;
                }

                bool result;
                try {
                    if (method.ReturnType == typeof(void)) {
                        method.Invoke(fromState, null);
                        result = true;
                    } else {
                        result = (bool)method.Invoke(fromState, null);
                    }
                } catch (Exception e) {
                    Debug.LogException(e);
                    
                    result = false;
                }

                if (!result) {
                    ruleTransition = default;
                    return;
                }

                try {
                    stateMachine.RuleTriggered?.Invoke(stateType, method.Name);
                } catch (Exception e) {
                    Debug.LogException(e);
                }

                ruleTransition = new RuleTransition<T>(method.Name, default, RuleTransitionKind.Pop);
            }
        }

        public void Update() {
            bool anyTransition;
            do {
                anyTransition = false;
                if (this.Current is not { } currentState) {
                    break;
                }

                if (this.FindTransition(in currentState, out var transition)) {
                    anyTransition = true;
                    this.DoTransition(in transition);
                }
            } while (anyTransition);
        }

        protected virtual bool FindTransition(in T fromState, out RuleTransition<T> transition) {
            transition = default;

            if (!this.transitionRules.TryGetValue(fromState.GetType(), out var rulesList)) {
                return false;
            }

            foreach (var rule in rulesList) {
                rule.Delegate?.Invoke(this, fromState, out transition);

                if (this.DoTransition(in transition)) {
                    return true;
                }
            }

            return false;
        }

        private bool DoTransition(in RuleTransition<T> ruleTransition) {
            switch (ruleTransition.TransitionKind) {
                case RuleTransitionKind.Pop when this.Count > 0: {
                    this.Pop();
                    return true;
                }

                case RuleTransitionKind.Push: {
                    this.Push(ruleTransition.ToState);
                    return true;
                }

                case RuleTransitionKind.Replace: {
                    this.Replace(ruleTransition.ToState);
                    return true;
                }

                case RuleTransitionKind.Reset: {
                    this.Reset(ruleTransition.ToState);
                    return true;
                }

                default: {
                    return false;
                }
            }
        }
    }
}
